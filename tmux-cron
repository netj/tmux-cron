#!/usr/bin/env uv run --script
# /// script
# dependencies = [
#   "croniter",
#   "pyyaml",
#   "tmuxp",
# ]
# ///

import os
import sys
import subprocess
import shutil
import tempfile
from datetime import datetime
from pathlib import Path

# Configuration
BASE_DIR = Path.home() / ".tmux-cron"
CRONTAB_FILE = BASE_DIR / "crontab"
YAML_FILE = BASE_DIR / "session.yaml"
BRIDGE_SCRIPT = BASE_DIR / "bridge.sh"
SESSION_NAME = "tmux-cron"
RUNNER_PATH = os.path.abspath(__file__)

BASE_DIR.mkdir(parents=True, exist_ok=True)

def sh(cmd: str, **env_vars):
    current_env = os.environ.copy()
    current_env.update({k: str(v) for k, v in env_vars.items()})
    return subprocess.run(["bash", "-c", cmd], env=current_env, stdout=sys.stdout, stderr=sys.stderr)

def generate_assets(lines, dry_run=False):
    import yaml
    
    yaml_dict = {"session_name": SESSION_NAME, "windows": []}
    panes = []
    env_lines = ["#!/bin/bash"]
    
    for i, line in enumerate(lines):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        
        # Parse ENV=VALUE
        if "=" in line and not line.startswith("@") and not line[0].isdigit() and "*" not in line.split('=')[0]:
            env_lines.append(f'export {line}')
            continue

        parts = line.split(maxsplit=5)
        if len(parts) < 2: continue
        
        schedule = parts[0]
        if schedule.startswith("@"):
            command = " ".join(parts[1:])
        else:
            if len(parts) < 6: continue
            schedule, command = " ".join(parts[:5]), parts[5]
        
        from croniter import croniter
        if schedule != "@reboot" and not croniter.is_valid(schedule):
            raise ValueError(f"Invalid schedule on line {i+1}: {schedule}")

        # The runner call for tmuxp
        run_cmd = f'"{RUNNER_PATH}" --run "{schedule}" "{command}"'
        panes.append(run_cmd)

    # Finish bridge script: it exports vars then runs args
    env_lines.append('exec "$@"')
    
    if not dry_run:
        BRIDGE_SCRIPT.write_text("\n".join(env_lines))
        BRIDGE_SCRIPT.chmod(0o755)
        
        # Use Literal Block Scalar for the tmuxp command
        class LiteralStr(str): pass
        def literal_presenter(dumper, data):
            return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')
        yaml.add_representer(LiteralStr, literal_presenter)

        yaml_dict["windows"].append({
            "window_name": "cron-jobs",
            "layout": "tiled",
            "panes": [LiteralStr(p) for p in panes]
        })
        
        with open(YAML_FILE, "w") as f:
            yaml.dump(yaml_dict, f, default_flow_style=False)
            
    return yaml_dict

def sync_and_launch(attach=True):
    if not CRONTAB_FILE.exists():
        print("No crontab found. Use 'tmux-cron -e' to create one.")
        return
    
    is_stale = not YAML_FILE.exists() or CRONTAB_FILE.stat().st_mtime > YAML_FILE.stat().st_mtime
    if is_stale:
        print("Crontab changed. Regenerating assets...")
        generate_assets(CRONTAB_FILE.read_text().splitlines())
        sh('tmux kill-session -t "$SESSION" 2>/dev/null', SESSION=SESSION_NAME)
    
    sh('tmux has-session -t "$SESSION" 2>/dev/null || uv run tmuxp load -d "$CONFIG"', 
       SESSION=SESSION_NAME, CONFIG=str(YAML_FILE))
    
    if attach:
        sh('tmux attach -t "$SESSION"', SESSION=SESSION_NAME)

def cron_runner(schedule, command):
    from croniter import croniter
    import time

    sh('tmux set-option -p -t "$TMUX_PANE" automatic-rename off')
    sys.stdout.write(f"\033c\033]2;{command}\007")
    sys.stdout.flush()

    print(f"tmux-cron started: {schedule} {command}\n")

    def execute():
        timestamp = datetime.now().strftime('%Y-%m-%d %a %H:%M:%S')
        print(f"[{timestamp}] Executing...")
        # Run through the bridge to pick up crontab environment variables
        sh('"$BRIDGE" bash -c "$CMD"', BRIDGE=str(BRIDGE_SCRIPT), CMD=command)

    if schedule == "@reboot":
        execute()
        while True: time.sleep(86400)

    iter = croniter(schedule, datetime.now())
    while True:
        next_run = iter.get_next(datetime)
        sleep_time = (next_run - datetime.now()).total_seconds()
        if sleep_time > 0:
            time.sleep(sleep_time)
        execute()

if __name__ == "__main__":
    args = sys.argv[1:]
    if not args:
        sync_and_launch(attach=True)
    elif args[0] in ["-e", "--edit"]:
        if not CRONTAB_FILE.exists(): CRONTAB_FILE.write_text("# PATH=/usr/bin:/bin\n# @reboot echo 'Started'\n")
        with tempfile.NamedTemporaryFile(suffix=".tmp", delete=False) as tmp:
            shutil.copyfile(CRONTAB_FILE, tmp.name)
            sh('${EDITOR:-nano} "$TARGET"', TARGET=tmp.name)
            try:
                with open(tmp.name, 'r') as f: generate_assets(f.readlines(), dry_run=True)
                shutil.copyfile(tmp.name, CRONTAB_FILE)
                sync_and_launch(attach=True)
            except Exception as e: print(f"Error: {e}")
            finally: os.unlink(tmp.name)
    elif args[0] in ["-l", "--list"]:
        print(CRONTAB_FILE.read_text() if CRONTAB_FILE.exists() else "Empty.")
    elif args[0] in ["-a", "--attach"]:
        sh('tmux attach -t "$SESSION"', SESSION=SESSION_NAME)
    elif args[0] == "--run" and len(args) == 3:
        cron_runner(args[1], args[2])
    else:
        print("Usage: tmux-cron [-e|-l|-a]")